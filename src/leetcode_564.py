"""
Answer generated by ChatGPT.

Summary of approach:

1. Generate edge case palindromes:
    - The largest palindrome with fewer digits (e.g., 999 for 1000).
    - The smallest palindrome with more digits (e.g., 10001 for 9999).

2. Modify the first half of the input number by -1, 0, and +1.
    - For each variation, create a palindrome by mirroring the first half.
    - If the length of n is odd, exclude the middle digit when mirroring.

3. Discard the original number from the list of candidate palindromes.

4. Compare all candidate palindromes to find the one with the smallest
   absolute difference to the original number.
    - In case of a tie (equal distance), return the smaller palindrome.

https://leetcode.com/problems/find-the-closest-palindrome/

#2024 #revisit
"""

class Solution:
    def nearestPalindromic(self, n):
        """
        :type n: str
        :rtype: str
        """
        length = len(n)

        # Generate some edge candidates (smallest and largest possible palindromes)
        candidates = set()
        candidates.add(str(10 ** (length - 1) - 1))  # like 999 for 1000
        candidates.add(str(10 ** length + 1))  # like 10001 for 9999

        # Get the first half of the number (important for generating palindromes)
        first_half = int(n[: (length + 1) // 2])

        # Create potential palindromes by modifying the first half
        for i in [-1, 0, 1]:
            prefix = str(first_half + i)

            if length % 2 == 0:
                palindrome = prefix + prefix[::-1]
            else:
                palindrome = prefix + prefix[:-1][::-1]

            candidates.add(palindrome)

        # TODO: debugging
        print(candidates)

        # Remove the original number itself from the candidates
        candidates.discard(n)

        # Find the closest palindrome by comparing absolute differences
        def closest(candidate):
            return abs(int(candidate) - int(n)), int(candidate)

        return min(candidates, key=closest)
